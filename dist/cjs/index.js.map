{"version":3,"file":"index.js","sources":["../../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../../node_modules/tslib/tslib.es6.js","../../node_modules/three/examples/jsm/loaders/GLTFLoader.js","../../src/components/ModularMesh/ModularMesh.tsx"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenColor.fromArray( extension.sheenColorFactor );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n",null],"names":["toTrianglesDrawMode","geometry","drawMode","TrianglesDrawMode","console","warn","TriangleFanDrawMode","TriangleStripDrawMode","index","getIndex","indices","position","getAttribute","undefined","error","i","count","push","setIndex","numberOfTriangles","newIndices","getX","length","newGeometry","clone","clearGroups","SuppressedError","GLTFLoader","Loader","constructor","manager","super","this","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","load","url","onLoad","onProgress","onError","scope","resourcePath","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","indexOf","unregister","splice","json","extensions","plugins","textDecoder","TextDecoder","JSON","ArrayBuffer","decode","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","version","GLTFParser","crossOrigin","fileLoader","plugin","name","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","Promise","resolve","reject","GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","color","Color","fromArray","range","type","DirectionalLight","target","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self","then","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","SRGBColorSpace","all","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","Infinity","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","bufferView","bufferViews","extensionDef","buffer","decoder","supported","res","byteOffset","byteLength","stride","byteStride","decodeGltfBufferAsync","mode","filter","ready","result","decodeGltfBuffer","createNodeMesh","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","attributes","accessor","results","nodeObject","pop","isGroup","children","instancedMeshes","m","Matrix4","p","Vector3","q","Quaternion","s","instancedMesh","InstancedMesh","material","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","attributeName","setAttribute","Object3D","prototype","copy","call","assignFinalMaterial","clear","BINARY_EXTENSION_CHUNK_TYPES","body","headerView","DataView","header","magic","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","attribute","extendTexture","texture","transform","texCoord","channel","offset","rotation","repeat","needsUpdate","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","updateMorphTargets","il","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","keys","sort","getNormalizedComponentScale","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","test","userAgent","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","map","def","bufferIndex","bufferDef","buffers","resolveURL","bufferViewDef","accessorIndex","sparse","itemSize","TypedArray","BufferAttribute","pendingBufferViews","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","URL","webkitURL","sourceURI","isObjectURL","blob","Blob","mimeType","createObjectURL","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","search","mapName","mapDef","colorSpace","gltfReference","useDerivativeTangents","tangent","useVertexColors","useFlatShading","normal","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","y","MeshStandardMaterial","materialType","kmuExtension","metalness","metallicFactor","roughness","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissive","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","depthTest","FrontSide","geometries","SkinnedMesh","Mesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","group","Group","cameraIndex","cameraDef","params","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","updateMatrix","createdTracks","_createAnimationTracks","k","AnimationClip","traverse","o","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","matrix","applyMatrix4","quaternion","has","sceneIndex","sceneDef","nodeIds","reducedAssociations","value","reduceAssociations","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","_getArrayFromAccessor","j","jl","track","_createCubicSplineTrackInterpolant","scaled","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","assignAttributeAccessor","gltfAttributeName","box","Box3","min","max","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","addMorphTargets"],"mappings":"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","x_google_ignoreList":[0,1,2]}